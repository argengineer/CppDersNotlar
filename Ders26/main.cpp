#include <iostream>
#include <string>
#include <random>

#include "Car.h"

// dynamic cast downcasting yapar. Onceki ders notlarinda dynamic cast ornekleri verilmistir.

void car_game(car4* carptr)
{
    carptr->start();
    carptr->run();
    if (auto vp = dynamic_cast<Volvo3*>(carptr); vp != nullptr )
    {
        vp->open_sunroof();
    }
    carptr->stop();
}

// if with initilazier dile c++17 ile eklenmistir.

// Nullptr'nin kullanildigi uygulamalarda direkt olarak referans kullanamayiz cunku null pointer vardir ama bunun referans duzleminde bir karsiligi yoktur.

void car_gameref(car4& cref)
{
    cref.start();
    cref.run();
    auto vref = dynamic_cast<Volvo3&>(cref);
    vref.open_sunroof();
    vref.stop();

}

void f_cargameref()
{
    VolvoS80 vx;
    car_gameref(vx);
    std::cout << "main devam ediyo\n";

    Fiat3 fx;
    car_gameref(fx);    // bunun cagirilmasinda, dynamic cast isleminde hata oldugu icin bir exeption gerceklesecek. 'std::bad_cast' exeption'u alacagim.
    std::cout << "main devam edemiyo\n";
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Typeid operatoru

// typeid operatorunun urettigi deger ismi std::type_info olan bir sinif turunden bir const referanst'tir. 

#include <typeinfo> // bunu include etmeliyiz!

// typeinfo turunden bir sinif olusturamayiz biz
// std::typeinfo x; bu sekilde bir sey tanimlayamam cunku bunun default ctor'u yok!

void f_kdr1(){
    int ival{15};
    // std::type_info& x = typeid(ival); bu sekilde kullanim hatalidir
    const std::type_info& x = typeid(ival); // bu sekilde kullanim ise legaldir const correctness'a dikkat etmek gerekir.
}

/*
    typeid(Myclass)
    typeid(int)
    typeid(double)
    her tur icin bir type info nesnesi var.
    typeid(double) == typeid(double) -- bana true deger doner. == boolean kullanabiliriz.

*/

void f_kdr2()
{
    int x{23};
    std::cout << typeid(x).name() << "\n";
    std::cout << typeid(x+0.2).name() << "\n";
    std::cout << typeid("x+0.2").name() << "\n";
    std::cout << typeid('x').name() << "\n";
}

 
/*
    unvelouated context. Compilerin islem yapmadigi durum gibi dusunulebilir.
    1) size
        int x = 56;
        size(x++);
        std::cout <<< x; // yaparsak cevap 56'dır. Size icerisindeki x++ bir islem uretmez.

    2) typeid
        int x = 56;
        std::cout << typeid(x++).name;
        std::cout << x; // cevap yine 56'dır.

    3) decltype operatoru
*/

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class base1{
    public:
};

class der1 : public base1{

};

void f_kdr3()
{
    der1  myder1;
    base1* baseptr = &myder1;
    
    std::cout << ( typeid(*baseptr) == typeid(base1) ) << "\n"; // Buranin ciktisi 1'dir.

    std::cout << typeid(*baseptr).name() << "\n";   // burada cikti base1'dir cunku base1 polimorfik bir class su an icin degildir.
}

//////////////////////////////////////

class base2{
    public:
    virtual ~base2(){}
};

class der2 : public base2{

};

void f_kdr4()
{
    der2  myder2;
    base2* baseptr = &myder2;

    std::cout << typeid(*baseptr).name() << "\n";   // burada cikti der2'dir cunku base1 artik polimorfik bir classtir.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void car_game1(car4& cr)
{
    std::cout << cr << "\n";
    cr.start();
    cr.run();
    if(typeid(cr) == typeid(Volvo3))
    {    
        static_cast<Volvo3&>(cr).open_sunroof();
    }
    cr.stop();
}

void f_kdr5()
{
    for (int i = 0; i < 100; i++)
    {
        car4* p = create_random_car3();
        car_game1(*p);
        getchar();
        delete(p);
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Multiple inheritance
// multiple inheritance, multilevel inheritance demek degildir. Buna dikkat edelim.
// Bir sinifin birden fazla taban siniflar kalitilmasina denir.
// iki ve 3 cok yaygin kullanilan taban sinif sayisi. 

class base3{};

class base3a{};

//class der3 : public base3, /*private*/ base3a{};    // eger basina public ile belirtmezsen bu sekilde bir sonuc almis olursun. yani default private olur. her class'i 
                                                    // belirtmek gerekir.

class der3 : public base3, public base3a{};

void f_kdr6()
{
    der3 myder;

    base3* mybptr = &myder;
    base3a* myaptr = &myder;

    base3 bref = myder;
    base3a aref = myder;

    // Bu sekilde kullanabilirim.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class base4_a{
    public:
        void foo(int,int){}
};

class base4_b{
    public:
        void foo(int){}
};

class der4 : public base4_a, public base4_b
{

};


void f_kd7()
{
    der4 myder4;
    // myder4 foo(3);   // bu sekilde kullanamam, yorumlari kaldirinca hata olustugu gorulur. Burada function overloading yoktur.
    myder4.base4_a::foo(12,23);
    myder4.base4_b::foo(12); // bu sekilde kullanabiliriim ancak.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Diamond Formation (Elmas formasyonu)
// DDD dreadful diamond of derivation - kalitimin olumcul elmasi
// bunu asmanin yolu virtual inheritance'dir.

class a1x{
    public:
    a1x(){
        std::cout << "a1'in clasii burasidir \n";
    }
};

class b1x : public a1x{
    public:
        b1x(){
        std::cout << "b1'in clasii burasidir \n";
    }
};

class b2x : public a1x{
    public:
        b2x(){
        std::cout << "b2'in clasii burasidir \n";
    }
};

class MA1 : public b1x, public b2x{
    public:
    MA1(){
        std::cout << "MA1'in clasii burasidir \n";
    }
};

void f_kdr8()
{
    MA1 myder; // program bu sekilde calistirilip incelendiginde, a1x class'inin birden fazla inherit edildigi gorulur. Bu istenmeyen bir durumdur.
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Device{
    public:
        void turn_on()
        {
            m_flag = true;
        }

        void turn_off()
        {
            m_flag = false;
        }

        bool is_on()const
        {
            return m_flag;
        }

    private:
        bool m_flag{};  // default olarak false init edilir.
};

class Fax : virtual public Device{
    public:
        void turn_on()
        {
            Device::turn_on();
        }

        void send_fax(){
            if(is_on()){
                std::cout << "cihaz acik ve fax gonderildi\n";
            }else{
                std::cout << "cihaz kapali oldugundan fax gonderilemedi\n";
            }

        }
        void receive_fax(){}

};

class modem : virtual public Device{
    public:
        void turn_on()
        {
            Device::turn_on();
        }

        void send_data(){
            if(is_on()){
                std::cout << "cihaz acik ve data gonderildi\n";
            }else{
                std::cout << "cihaz kapali oldugundan data gonderilemedi\n";
            }
        }
        
        void receive_data(){

        }
        
};

class FaxModem : public Fax , public modem {
    public:
        
};

void f_kdr9()
{
    FaxModem fm;
    fm.Fax::turn_on();
    fm.send_fax();
    fm.send_data();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class ex_base1{
    public:
        void foo(){}
};

class ex_der1 : virtual public ex_base1{

};

class ex_der2 : virtual public ex_base1{

};

class ex_mder1 : public ex_der1, public ex_der2{

};

void ex_foo1()
{
    ex_mder1 myder;
    myder.foo();    // su an icin bu fonksiyonu cagirabiliyorum ama virtual ettigim 2 class'i virtual etmeseydim bu fonksiyonu cagiramayacaktim cunku ambiguity olusacakti.

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class ex_base2{
    public:        
        ex_base2(int x){
            std::cout << x << "\n";
        }
        
};

class ex_der3 : virtual public ex_base2{
    public:
        ex_der3() : ex_base2(1)
        {

        }
};

class ex_der4 : virtual public ex_base2{
    public:
        ex_der4() : ex_base2(2)
        {
            
        }
};

class ex_mder2 : public ex_der3, public ex_der4{
    public:
        ex_mder2() : ex_base2(4) {        } // bu ornegin yazilmasinin sebebi bu satiri yoruma aldigimizda ortaya cikan hatadir. Yani su gorulmelidir,
        // base class'i inherit eden 2 farkli virtual class var ama ikisi de iki farkli sekilde base class'in constructor'ini cagiriyor. Birisi 1 ile cagirirken
        // digeri 2 ile cagiriyor. Boyle bir durumda mecburen base class'i bu sekilde cagirmamiz gerekmektedir ki hataya sebebiyet vermemis olalim.
};

class kdrDer : public ex_mder2{
    public:
        kdrDer(int x) : ex_base2(x)
        {

        }
};

void ex_foo2()
{
    ex_mder2 myder;
    kdrDer mykdr(3);    // bu class'in nereden geldigine de bakmak faideli olacaktir.

}

int main() 
{
    f_kdr9();
    return 0;
}

 